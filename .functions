#!/bin/bash
#echo "sourcing .functions"

# function dotadm {
#    `which git` --git-dir=$HOME/.home/ --work-tree=$HOME $@
# }

### Functions for setting and getting environment variables from the OSX keychain ###
### Adapted from https://www.netmeister.org/blog/keychain-passwords.html ###

# Use: keychain-environment-variable SECRET_ENV_VAR
function keychain-environment-variable () {
    security find-generic-password -w -a "${ACCOUNT:-$USER}" -D "environment variable" -s "${WHERE:-$1}"
}

# Use: set-keychain-environment-variable SECRET_ENV_VAR
#   provide: super_secret_key_abc123
function set-keychain-environment-variable () {
    [ -n "$1" ] || print "Missing environment variable name"

    # Note: if using bash, use `-p` to indicate a prompt string, rather than the leading `?`
    read -p "Enter Value for ${1}: " secret

    ( [ -n "$1" ] && [ -n "$secret" ] ) || return 1
    security add-generic-password -U -a "${USER}" -D "environment variable" -s "${1}" -w "${secret}"
}

# Start SSH Agent{{{
#----------------------------
# Add this to bashrc in cygwin environments

# if [ -f "${SSH_ENV}" ]; then
#   run_ssh_env;
#   ps -ef | grep ${SSH_AGENT_PID} | grep ssh-agent$ > /dev/null || {
#     start_ssh_agent;
#   }
# else
#   start_ssh_agent;
# fi`
# SSH_ENV="$HOME/.ssh/environment"

function start_ssh_agent {
  ssh-add -l &>/dev/null
  if [ "$?" == 2 ]; then
    test -r ~/.ssh-agent && \
      eval "$(<~/.ssh-agent)" >/dev/null

    ssh-add -l &>/dev/null
    if [ "$?" == 2 ]; then
      (umask 066; ssh-agent > ~/.ssh-agent)
      eval "$(<~/.ssh-agent)" >/dev/null
      ssh-add
    fi
  fi
}

sshfun() {
  HOST=$1
  COMMAND=$2
  PARAM="${@:3}"
  ssh ${HOST} "$(declare -f ${COMMAND}); ${COMMAND} ${PARAM}"
}
#}}}

setenv()
{
  export "$1='$2'"
}
unsetenv()
{
  unset "$1"
}

## Include file only if it exists
include () {
    [[ -f "$1" ]] && source "$1"
}

# display man pages in web browser
function wman() {
   local url="man -w ${1} | sed 's#.*\(${1}.\)\([[:digit:]]\).*\$#http://developer.apple.com/documentation/Darwin/Reference/ManPages/man\2/\1\2.html#'"
   open `eval $url`
}

# Growl function for iTerm
growl() { echo -e $'\e]9;'${1}'\007' ; return ; }

#display man pages in Preview.app
pman()
{
  man -t "$@" | open -f -a Preview || { echo "bar() failed"; return 1; }
}

function mask(){
  # Changes MAC address to a random one and sets the hostname to a random word
  # Tested on OS X 10.9 (Macbook Pro)
  # Based on http://blog.kejsarmakten.se/all/software/2013/08/30/spoof-mac-on-osx.html
  # and http://osxdaily.com/2010/09/06/change-your-mac-hostname-via-terminal/
  # Note: neither are permanent (a reboot resets both)
  # For a permanent change to hostname: sudo scutil â€“-set HostName NEWHOST
  # Consider using SpoofMAC: https://github.com/feross/SpoofMAC
    OLDMAC=$(ifconfig en0 | awk '/ether/ {print $2}')
    RANDMAC=$(openssl rand -hex 6 | sed 's/\(..\)/\1:/g; s/.$//')
    echo "Attempting to Change MAC $OLDMAC to $RANDMAC"
    sudo ifconfig en0 ether $RANDMAC
    NEWMAC=$(ifconfig en0 | awk '/ether/ {print $2}')
    if [ $OLDMAC == $NEWMAC ] ; then
      echo "Mac address was not able to be changed"
    else
      echo "New MAC is: " $NEWMAC
    fi
   # NEWHOST=$(sed `perl -e "print int rand(99999)"`"q;d" /usr/share/dict/words)
   # echo "Changing hostname: " $(hostname)
   # sudo hostname $NEWHOST
   # echo "New hostname is:" $(hostname)
}

function unmask(){
    sudo ifconfig en0 ether $OLDMAC
    [ "$?" == "0" ] && echo "MAC address returned to $OLDMAC"
}

# Generate random password of argument length
# genpasswd 16
genpasswd() {
  local l=$1
    [ "$l" == "" ] && l=20
    tr -dc A-Za-z0-9_ < /dev/urandom | head -c ${l} | xargs
}

# Open Tmux pane for commands like watch
# e.g. tmw watch uptime
tw() {
  tmux split-window -dh "${*}"
  # tmux split-window -dh "$(eval echo \$"$1")"
}

# Print list of 256 xterm colors
colours() {
  ( for i in {0..255}; do
    color="\x1b[38;5;${i}mcolour${i}\x1b[0m"
    printf "$color\n"
  done ) | column -t -c 2
}

settitle()
{
  case "$TERM" in
    xterm* )
      echo -ne '\e]0;'"$@"'\a'
    ;;
    screen)
      echo -ne '\ek'"$@"'\e\\'
    ;;
  esac
}

test_loop()
{
  host=$1
  ssh $host bash -c "'
  read -r perm id uid gid size month day time file <<< $(ls -l )
  echo "$time and $file"
  '"
}

##------------------------------------ ##
 #           -- new-alias --           #
 # creates new alias & writes to file  #
 #          $1 = alias new             #
 #          $2 = alias definition      #
##------------------------------------ ##
#new-alias () {
#  if [ -z "$1" ]; then
#    echo "alias name:"
#    read NAME
#  else
#    NAME=$1
#  fi
#
#  if [ -z "$2" ]; then
#    echo "alias definition:"
#    read DEFINTION
#  else
#    if [ "$2" = "-cd" ]; then
#      DEFINTION='cd '
#    else
#      DEFINTION=$2
#    fi
#  fi
#
#  echo "alias $NAME='$DEFINTION'" >> ~/.aliases
#  . ~/.aliases
#}

function save-alias() {
  local new_alias="$(alias | grep $1)"
  echo ${new_alias} >> ~/.aliases
}

save-trick() {
  # somehow the history retrieval command needs to be quoted before being sent to function
  local new_trick="$1"
  echo "${new_trick}" >> ~/.tricks
}

### Kubernetes Helpers
klog() {
    POD=$1
    INPUT_INDEX=$2
    INDEX="${INPUT_INDEX:-1}"
    PODS=`kubectl get pods --all-namespaces|grep ${POD} |head -${INDEX} |tail -1`
    PODNAME=`echo ${PODS} |awk '{print $2}'`
    echo "Kenny says its Pod: ${PODNAME}"
    echo
    NS=`echo ${PODS} |awk '{print $1}'`
    kubectl logs -f --namespace=${NS} ${PODNAME}
}

wpod() {
    NS=$@
    NAMESPACE=${NS:-"--all-namespaces"}
    if [ "$NAMESPACE" != "--all-namespaces" ]
      then
      NAMESPACE="-n ${NS}"
    fi

    watch kubectl get pods $NAMESPACE
}

kexec() {
    POD=$1
    INPUT_INDEX=$2
    INDEX="${INPUT_INDEX:-1}"
    PODS=`kubectl get pods --all-namespaces|grep ${POD} |head -${INDEX} |tail -1`
    PODNAME=`echo ${PODS} |awk '{print $2}'`
    echo "Pod: ${PODNAME}"
    echo
    NS=`echo ${PODS} |awk '{print $1}'`
    kubectl exec -it --namespace=${NS} ${PODNAME} /bin/bash
}

kdesc() {
    POD=$1
    INPUT_INDEX=$2
    INDEX="${INPUT_INDEX:-1}"
    PODS=`kubectl get pods --all-namespaces|grep ${POD} |head -${INDEX} |tail -1`
    PODNAME=`echo ${PODS} |awk '{print $2}'`
    echo "Pod: ${PODNAME}"
    echo
    NS=`echo ${PODS} |awk '{print $1}'`
    kubectl describe pod --namespace=${NS} ${PODNAME}
}
export -f kdesc

kcid() {
  POD=$1
  INPUT_INDEX=$2
  INDEX="${INPUT_INDEX:-1}"
  PODS=`kubectl get pods --all-namespaces|grep ${POD} |head -${INDEX} |tail -1`
  PODNAME=`echo ${PODS} |awk '{print $2}'`
  echo "Pod: ${PODNAME}"
  echo
  NS=`echo ${PODS} |awk '{print $1}'`
  kubectl get pod --namespace=${NS} ${PODNAME} -o jsonpath={.status.containerStatuses[0].containerID}
  echo
}

### Docker Helpers

dipid() {
  #Return Process ID given docker container ID
  CID=$1  # Expecting Container ID in docker// form
  [[ -z "$CID" ]] && echo "Expecting containerID" && return 1
  beginswith() { case $2 in "$1"*) true;; *) false;; esac; }
  if beginswith docker "$CID"
  then
    CID=${CID:9}
  fi
  docker inspect --format '{{ .State.Pid }}' $CID
}
### Convert to Animated Gif

gif_me() {
  local images="$1"
  convert -delay 20 -loop 0 images loopingImage.gif
}

### Documenting Functions
## Attempting to asciidoc wrap a csv file
csv_table() {
  local csv_file="$1"
  table_string="$(cat <<EOF
.Test Table
[options="header,footer"]
|====
include::${csv_file}
|====
EOF
  )"
  echo "${table_string[*]}"

}

### Logging Functions
LOG_DIR=~/Logs
mkdir -p ${LOG_DIR}
SCRIPT_LOG=${LOG_DIR}/Script.log
touch ${SCRIPT_LOG}

function SCRIPTENTRY()
{
 local timeAndDate="`date`"
 script_name="${0##*/}"
 script_name="${script_name%.*}"
 echo "[$timeAndDate] [DEBUG]  > $script_name $FUNCNAME" >> $SCRIPT_LOG
}

function SCRIPTEXIT()
{
 script_name=`basename "$0"`
 script_name="${script_name%.*}"
 echo "[$timeAndDate] [DEBUG]  < $script_name $FUNCNAME" >> $SCRIPT_LOG
}

function ENTRY()
{
 local cfn="${FUNCNAME[1]}"
 timeAndDate=`date`
 echo "[$timeAndDate] [DEBUG]  > $cfn $FUNCNAME" >> $SCRIPT_LOG
}

function EXIT()
{
 local cfn="${FUNCNAME[1]}"
 timeAndDate=`date`
 echo "[$timeAndDate] [DEBUG]  < $cfn $FUNCNAME" >> $SCRIPT_LOG
}

function INFO()
{
 local function_name="${FUNCNAME[1]}"
 local msg="$1"
 timeAndDate=`date`
 echo "[$timeAndDate] [INFO]  $msg" >> $SCRIPT_LOG
}

function DEBUG()
{
 local function_name="${FUNCNAME[1]}"
 local msg="$1"
 timeAndDate=`date`
 echo "[$timeAndDate] [DEBUG]  $msg" >> $SCRIPT_LOG
}

function ERROR()
{
 local function_name="${FUNCNAME[1]}"
 local msg="$1"
 timeAndDate=`date`
 echo "[$timeAndDate] [ERROR]  $msg" >> $SCRIPT_LOG
}

# Home Brew Functions using FZF
# https://github.com/junegunn/fzf/wiki/examples

# Install (one or multiple) selected application(s)
# using "brew search" as source input
# mnemonic [B]rew [I]nstall [P]lugin
bip() {
  local inst=$(brew search | fzf -m)

  if [[ $inst ]]; then
    for prog in $(echo $inst); do brew install $prog; done;
  fi
}

# Update (one or multiple) selected application(s)
# mnemonic [B]rew [U]pdate [P]lugin
bup() {
  local upd=$(brew leaves | fzf -m)

  if [[ $upd ]]; then
    for prog in $(echo $upd); do brew upgrade $prog; done;
  fi
}

# Delete (one or multiple) selected application(s)
# mnemonic [B]rew [C]lean [P]lugin (e.g. uninstall)
bcp() {
  local uninst=$(brew leaves | fzf -m)

  if [[ $uninst ]]; then
    for prog in $(echo $uninst); do brew uninstall $prog; done;
  fi
}

# Freom https://stackoverflow.com/questions/957928/is-there-a-way-to-get-the-git-root-directory-in-one-command
# Print the name of the git working tree's root directory
function git_root() {
  local root first_commit
  # git displays its own error if not in a repository
  root=$(git rev-parse --show-toplevel) || return
  if [[ -n $root ]]; then
    echo $root
    return
  elif [[ $(git rev-parse --is-inside-git-dir) = true ]]; then
    # We're inside the .git directory
    # Store the commit id of the first commit to compare later
    # It's possible that $GIT_DIR points somewhere not inside the repo
    first_commit=$(git rev-list --parents HEAD | tail -1) ||
      echo "$0: Can't get initial commit" 2>&1 && false && return
    root=$(git rev-parse --git-dir)/.. &&
      # subshell so we don't change the user's working directory
    ( cd "$root" &&
      if [[ $(git rev-list --parents HEAD | tail -1) = $first_commit ]]; then
        pwd
      else
        echo "$FUNCNAME: git directory is not inside its repository" 2>&1
        false
      fi
    )
  else
    echo "$FUNCNAME: Can't determine repository root" 2>&1
    false
  fi
}

# Change working directory to git repository root
function cd_git_root() {
  local root
  root=$(git_root) || return 1  # git_root will print any errors
  cd "$root"
}

# GIT heart FZF
# -------------

is_in_git_repo() {
  git rev-parse HEAD > /dev/null 2>&1
}

fzf-down() {
  fzf --height 50% "$@" --border
}

# cd to directory in current repo
gcd() {
  is_in_git_repo || return
  git rev-parse --show-toplevel
}

# git files
gf() {
  is_in_git_repo || return
  git -c color.status=always status --short |
  fzf-down -m --ansi --nth 2..,.. \
    --preview '(git diff --color=always -- {-1} | sed 1,4d; cat {-1}) | head -500' |
  cut -c4- | sed 's/.* -> //'
}

# git branches 
gb() {
  is_in_git_repo || return
  git branch -a --color=always | grep -v '/HEAD\s' | sort |
  fzf-down --ansi --multi --tac --preview-window right:70% \
    --preview 'git log --oneline --graph --date=short --color=always --pretty="format:%C(auto)%cd %h%d %s" $(sed s/^..// <<< {} | cut -d" " -f1) | head -'$LINES |
  sed 's/^..//' | cut -d' ' -f1 |
  sed 's#^remotes/##'
}

# git tags
gt() {
  is_in_git_repo || return
  git tag --sort -version:refname |
  fzf-down --multi --preview-window right:70% \
    --preview 'git show --color=always {} | head -'$LINES
}

# git history with preview
gh() {
  is_in_git_repo || return
  git log --date=short --format="%C(green)%C(bold)%cd %C(auto)%h%d %s (%an)" --graph --color=always |
  fzf-down --ansi --no-sort --reverse --multi --bind 'ctrl-s:toggle-sort' \
    --header 'Press CTRL-S to toggle sort' \
    --preview 'grep -o "[a-f0-9]\{7,\}" <<< {} | xargs git show --color=always | head -'$LINES |
  grep -o "[a-f0-9]\{7,\}"
}

# git remotes
gr() {
  is_in_git_repo || return
  git remote -v | awk '{print $1 "\t" $2}' | uniq |
  fzf-down --tac \
    --preview 'git log --oneline --graph --date=short --pretty="format:%C(auto)%cd %h%d %s" {1} | head -200' |
  cut -d$'\t' -f1
}

# fzf git functions keybindings
bind '"\er": redraw-current-line'
bind '"\C-g\C-f": "$(gf)\e\C-e\er"' # Git Files
bind '"\C-g\C-b": "$(gb)\e\C-e\er"' # Git Branches
bind '"\C-g\C-t": "$(gt)\e\C-e\er"' # Git Tags
bind '"\C-g\C-h": "$(gh)\e\C-e\er"' # Git history
bind '"\C-g\C-r": "$(gr)\e\C-e\er"' # Git Remotes
