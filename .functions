#!/bin/bash
#echo "sourcing .functions"

# function dotadm {
#    `which git` --git-dir=$HOME/.home/ --work-tree=$HOME $@
# }

### Functions for setting and getting environment variables from the OSX keychain ###
### Adapted from https://www.netmeister.org/blog/keychain-passwords.html ###

# Use: keychain-environment-variable SECRET_ENV_VAR
function keychain-environment-variable () {
    security find-generic-password -w -a "${ACCOUNT:-$USER}" -D "environment variable" -s "${WHERE:-$1}"
}

# Use: set-keychain-environment-variable SECRET_ENV_VAR
#   provide: super_secret_key_abc123
# By default, the application which creates an item is trusted to access its data without warning. You can remove this default access by explicitly specifying an empty app pathname: -T "" If no keychain is specified, the password is added to the default keychain.

function set-keychain-environment-variable () {
    [ -n "$1" ] || echo "Missing environment variable name"

    # Note: if using bash, use `-p` to indicate a prompt string, rather than the leading `?`
    read -r "Enter Value for ${1}: " secret

    ( [ -n "$1" ] && [ -n "$secret" ] ) || return 1
    security add-generic-password -U -a "${ACCOUNT:-$USER}" -D "environment variable" -s "${1}" -w "${secret}" -T ""
}

# Start SSH Agent{{{
#----------------------------
# Add this to bashrc in cygwin environments

# if [ -f "${SSH_ENV}" ]; then
#   run_ssh_env;
#   ps -ef | grep ${SSH_AGENT_PID} | grep ssh-agent$ > /dev/null || {
#     start_ssh_agent;
#   }
# else
#   start_ssh_agent;
# fi`
# SSH_ENV="$HOME/.ssh/environment"

function start_ssh_agent {
  ssh-add -l &>/dev/null
  if [ "$?" == 2 ]; then
    test -r ~/.ssh-agent && \
      eval "$(<~/.ssh-agent)" >/dev/null

    ssh-add -l &>/dev/null
    if [ "$?" == 2 ]; then
      (umask 066; ssh-agent > ~/.ssh-agent)
      eval "$(<~/.ssh-agent)" >/dev/null
      ssh-add
    fi
  fi
}

sshfun() {
  HOST=$1
  COMMAND=$2
  PARAM="${@:3}"
  ssh ${HOST} "$(declare -f ${COMMAND}); ${COMMAND} ${PARAM}"
}
#}}}

setenv()
{
  export "$1='$2'"
}
unsetenv()
{
  unset "$1"
}

## Include file only if it exists
include () {
    [[ -f "$1" ]] && source "$1"
}

# display man pages in web browser
function wman() {
   local url="man -w ${1} | sed 's#.*\(${1}.\)\([[:digit:]]\).*\$#http://developer.apple.com/documentation/Darwin/Reference/ManPages/man\2/\1\2.html#'"
   open `eval $url`
}

# Growl function for iTerm
growl() { echo -e $'\e]9;'${1}'\007' ; return ; }

#display man pages in Preview.app
pman()
{
  man -t "$@" | open -f -a Preview || { echo "bar() failed"; return 1; }
}

function mask(){
  # Changes MAC address to a random one and sets the hostname to a random word
  # Tested on OS X 10.9 (Macbook Pro)
  # Based on http://blog.kejsarmakten.se/all/software/2013/08/30/spoof-mac-on-osx.html
  # and http://osxdaily.com/2010/09/06/change-your-mac-hostname-via-terminal/
  # Note: neither are permanent (a reboot resets both)
  # For a permanent change to hostname: sudo scutil â€“-set HostName NEWHOST
  # Consider using SpoofMAC: https://github.com/feross/SpoofMAC
    OLDMAC=$(ifconfig en0 | awk '/ether/ {print $2}')
    RANDMAC=$(openssl rand -hex 6 | sed 's/\(..\)/\1:/g; s/.$//')
    echo "Attempting to Change MAC $OLDMAC to $RANDMAC"
    sudo ifconfig en0 ether $RANDMAC
    NEWMAC=$(ifconfig en0 | awk '/ether/ {print $2}')
    if [ $OLDMAC == $NEWMAC ] ; then
      echo "Mac address was not able to be changed"
    else
      echo "New MAC is: " $NEWMAC
    fi
   # NEWHOST=$(sed `perl -e "print int rand(99999)"`"q;d" /usr/share/dict/words)
   # echo "Changing hostname: " $(hostname)
   # sudo hostname $NEWHOST
   # echo "New hostname is:" $(hostname)
}

function unmask(){
    sudo ifconfig en0 ether $OLDMAC
    [ "$?" == "0" ] && echo "MAC address returned to $OLDMAC"
}

# Generate random password of argument length
# genpasswd 16
genpasswd() {
  local l=$1
    [ "$l" == "" ] && l=20
    tr -dc A-Za-z0-9_ < /dev/urandom | head -c ${l} | xargs
}

# Open Tmux pane for commands like watch
# e.g. tmw watch uptime
tw() {
  tmux split-window -dh "${*}"
  # tmux split-window -dh "$(eval echo \$"$1")"
}

# Print list of 256 xterm colors
colours() {
  ( for i in {0..255}; do
    color="\x1b[38;5;${i}mcolour${i}\x1b[0m"
    printf "$color\n"
  done ) | column -t -c 2
}

settitle()
{
  case "$TERM" in
    xterm* )
      echo -ne '\e]0;'"$@"'\a'
    ;;
    screen)
      echo -ne '\ek'"$@"'\e\\'
    ;;
  esac
}

test_loop()
{
  host=$1
  ssh $host bash -c "'
  read -r perm id uid gid size month day time file <<< $(ls -l )
  echo "$time and $file"
  '"
}

##------------------------------------ ##
 #           -- new-alias --           #
 # creates new alias & writes to file  #
 #          $1 = alias new             #
 #          $2 = alias definition      #
##------------------------------------ ##
#new-alias () {
#  if [ -z "$1" ]; then
#    echo "alias name:"
#    read NAME
#  else
#    NAME=$1
#  fi
#
#  if [ -z "$2" ]; then
#    echo "alias definition:"
#    read DEFINTION
#  else
#    if [ "$2" = "-cd" ]; then
#      DEFINTION='cd '
#    else
#      DEFINTION=$2
#    fi
#  fi
#
#  echo "alias $NAME='$DEFINTION'" >> ~/.aliases
#  . ~/.aliases
#}

function save-alias() {
  local new_alias="$(alias | grep $1)"
  echo ${new_alias} >> ~/.aliases
}

save-trick() {
  # somehow the history retrieval command needs to be quoted before being sent to function
  local new_trick="$1"
  echo "${new_trick}" >> ~/.tricks
}

### Kubernetes Helpers
klog() {
    POD=$1
    INPUT_INDEX=$2
    INDEX="${INPUT_INDEX:-1}"
    PODS=`kubectl get pods --all-namespaces|grep ${POD} |head -${INDEX} |tail -1`
    PODNAME=`echo ${PODS} |awk '{print $2}'`
    echo "Kenny says its Pod: ${PODNAME}"
    echo
    NS=`echo ${PODS} |awk '{print $1}'`
    kubectl logs -f --namespace=${NS} ${PODNAME}
}

wpod() {
    NS=$@
    NAMESPACE=${NS:-"--all-namespaces"}
    if [ "$NAMESPACE" != "--all-namespaces" ]
      then
      NAMESPACE="-n ${NS}"
    fi

    watch kubectl get pods $NAMESPACE
}

kexec() {
    POD=$1
    INPUT_INDEX=$2
    INDEX="${INPUT_INDEX:-1}"
    PODS=`kubectl get pods --all-namespaces|grep ${POD} |head -${INDEX} |tail -1`
    PODNAME=`echo ${PODS} |awk '{print $2}'`
    echo "Pod: ${PODNAME}"
    echo
    NS=`echo ${PODS} |awk '{print $1}'`
    kubectl exec -it --namespace=${NS} ${PODNAME} /bin/bash
}

# Attempt to fzfy
fkexec() {
    local pod pods ns
    # pod_preview="--preview='kubectl -n {1} describe pod {2} '"
    pod_preview="--preview='echo namespace={1} pod={2}'"
    pods=$(kubectl get pods -A ) &&
    pod=$(echo "$pods" |
    fzf --header-lines=1 --nth='1,2' \
    --height="50%" \
    --min-height=17 \
    --preview='kubectl -n {1} describe pod {2} ' )
    # sed 's/^..//' | cut -d' ' -f1 |
    # sed 's#^remotes/##')
    ns=$(echo ${pod} |awk '{print $1}')
    podname=$(echo $pod | awk '{print $2}')
    kubectl exec -it --namespace=${ns} ${podname} /bin/bash
}

kdesc() {
    POD=$1
    INPUT_INDEX=$2
    INDEX="${INPUT_INDEX:-1}"
    PODS=`kubectl get pods --all-namespaces|grep ${POD} |head -${INDEX} |tail -1`
    PODNAME=`echo ${PODS} |awk '{print $2}'`
    echo "Pod: ${PODNAME}"
    echo
    NS=`echo ${PODS} |awk '{print $1}'`
    kubectl describe pod --namespace=${NS} ${PODNAME}
}

kcid() {
  POD=$1
  INPUT_INDEX=$2
  INDEX="${INPUT_INDEX:-1}"
  PODS=`kubectl get pods --all-namespaces|grep ${POD} |head -${INDEX} |tail -1`
  PODNAME=`echo ${PODS} |awk '{print $2}'`
  echo "Pod: ${PODNAME}"
  echo
  NS=`echo ${PODS} |awk '{print $1}'`
  kubectl get pod --namespace=${NS} ${PODNAME} -o jsonpath={.status.containerStatuses[0].containerID}
  echo
}

### Docker Helpers

dipid() {
  #Return Process ID given docker container ID
  CID=$1  # Expecting Container ID in docker// form
  [[ -z "$CID" ]] && echo "Expecting containerID" && return 1
  beginswith() { case $2 in "$1"*) true;; *) false;; esac; }
  if beginswith docker "$CID"
  then
    CID=${CID:9}
  fi
  docker inspect --format '{{ .State.Pid }}' $CID
}
### Convert to Animated Gif

gif_me() {
  local images="$1"
  convert -delay 20 -loop 0 images loopingImage.gif
}

### Documenting Functions
## Attempting to asciidoc wrap a csv file
csv_table() {
  local csv_file="$1"
  table_string="$(cat <<EOF
.Test Table
[options="header,footer"]
|====
include::${csv_file}
|====
EOF
  )"
  echo "${table_string[*]}"

}

### Logging Functions
LOG_DIR=~/Logs
mkdir -p ${LOG_DIR}
SCRIPT_LOG=${LOG_DIR}/Script.log
touch ${SCRIPT_LOG}

function SCRIPTENTRY()
{
 local timeAndDate="`date`"
 script_name="${0##*/}"
 script_name="${script_name%.*}"
 echo "[$timeAndDate] [DEBUG]  > $script_name $FUNCNAME" >> $SCRIPT_LOG
}

function SCRIPTEXIT()
{
 script_name=`basename "$0"`
 script_name="${script_name%.*}"
 echo "[$timeAndDate] [DEBUG]  < $script_name $FUNCNAME" >> $SCRIPT_LOG
}

function ENTRY()
{
 local cfn="${FUNCNAME[1]}"
 timeAndDate=`date`
 echo "[$timeAndDate] [DEBUG]  > $cfn $FUNCNAME" >> $SCRIPT_LOG
}

function EXIT()
{
 local cfn="${FUNCNAME[1]}"
 timeAndDate=`date`
 echo "[$timeAndDate] [DEBUG]  < $cfn $FUNCNAME" >> $SCRIPT_LOG
}

function INFO()
{
 local function_name="${FUNCNAME[1]}"
 local msg="$1"
 timeAndDate=`date`
 echo "[$timeAndDate] [INFO]  $msg" >> $SCRIPT_LOG
}

function DEBUG()
{
 local function_name="${FUNCNAME[1]}"
 local msg="$1"
 timeAndDate=`date`
 echo "[$timeAndDate] [DEBUG]  $msg" >> $SCRIPT_LOG
}

function ERROR()
{
 local function_name="${FUNCNAME[1]}"
 local msg="$1"
 timeAndDate=`date`
 echo "[$timeAndDate] [ERROR]  $msg" >> $SCRIPT_LOG
}

# Freom https://stackoverflow.com/questions/957928/is-there-a-way-to-get-the-git-root-directory-in-one-command
# Print the name of the git working tree's root directory
function git_root() {
  local root first_commit
  # git displays its own error if not in a repository
  root=$(git rev-parse --show-toplevel) || return
  if [[ -n $root ]]; then
    echo $root
    return
  elif [[ $(git rev-parse --is-inside-git-dir) = true ]]; then
    # We're inside the .git directory
    # Store the commit id of the first commit to compare later
    # It's possible that $GIT_DIR points somewhere not inside the repo
    first_commit=$(git rev-list --parents HEAD | tail -1) ||
      echo "$0: Can't get initial commit" 2>&1 && false && return
    root=$(git rev-parse --git-dir)/.. &&
      # subshell so we don't change the user's working directory
    ( cd "$root" &&
      if [[ $(git rev-list --parents HEAD | tail -1) = $first_commit ]]; then
        pwd
      else
        echo "$FUNCNAME: git directory is not inside its repository" 2>&1
        false
      fi
    )
  else
    echo "$FUNCNAME: Can't determine repository root" 2>&1
    false
  fi
}

# Change working directory to git repository root
function cd_git_root() {
  local root
  root=$(git_root) || return 1  # git_root will print any errors
  cd "$root"
}

# GIT heart FZF
# ------------- https://gist.github.com/junegunn/8b572b8d4b5eddd8b85e5f4d40f17236

is_in_git_repo() {
  git rev-parse HEAD > /dev/null 2>&1
}

fzf-down() {
  fzf --height 50% "$@" --border
}

# cd to directory in current repo
gcd() {
  is_in_git_repo || return
  git rev-parse --show-toplevel
}

# git files
gf() {
  is_in_git_repo || return
  git -c color.status=always status --short |
  fzf-down -m --ansi --nth 2..,.. \
    --preview '(git diff --color=always -- {-1} | sed 1,4d; cat {-1}) | head -500' |
  cut -c4- | sed 's/.* -> //'
}

# git branches
gb() {
  is_in_git_repo || return
  git branch -a --color=always | grep -v '/HEAD\s' | sort |
  fzf-down --ansi --multi --tac --preview-window right:70% \
    --preview 'git log --oneline --graph --date=short --color=always --pretty="format:%C(auto)%cd %h%d %s" $(sed s/^..// <<< {} | cut -d" " -f1) | head -'$LINES |
  sed 's/^..//' | cut -d' ' -f1 |
  sed 's#^remotes/##'
}

# git diff
gd() {
  is_in_git_repo || return
  preview="git diff $@ --color=always -- {-1}"
  git diff $@ --name-only | fzf -m --ansi --preview $preview
}

# fbr - checkout git branch (including remote branches), sorted by most recent commit, limit 30 last branches
# Example from https://github.com/junegunn/fzf/wiki/examples but doesn't include color or preview
fbr() {
  local branches branch
  branches=$(git branch -a --color=always | grep -v '/HEAD\s' | sort) &&
  branch=$(echo "$branches" |
    fzf-down --ansi --multi --tac --preview-window right:70% \
      --preview 'git log --oneline --graph --date=short --color=always --pretty="format:%C(auto)%cd %h%d %s" $(sed s/^..// <<< {} | cut -d" " -f1) | head -'$LINES |
    sed 's/^..//' | cut -d' ' -f1 |
    sed 's#^remotes/##')
  echo $branch
}

# git history with preview
gh() {
  is_in_git_repo || return
  git log --date=short --format="%C(green)%C(bold)%cd %C(auto)%h%d %s (%an)" --graph --color=always |
  fzf-down --ansi --no-sort --reverse --multi --bind 'ctrl-s:toggle-sort' \
    --header 'Press CTRL-S to toggle sort' \
    --preview 'grep -o "[a-f0-9]\{7,\}" <<< {} | xargs git show --color=always | head -'$LINES |
  grep -o "[a-f0-9]\{7,\}"
}

# git remotes
gr() {
  is_in_git_repo || return
  git remote -v | awk '{print $1 "\t" $2}' | uniq |
  fzf-down --tac \
    --preview 'git log --color=always --oneline --graph --date=short --pretty="format:%C(auto)%cd %h%d %s" {1} | head -200' |
  cut -d$'\t' -f1
}

# fstash - easier way to deal with stashes
# type fstash to get a list of your stashes
# enter shows you the contents of the stash
# ctrl-d shows a diff of the stash against your current HEAD
# ctrl-b checks the stash out as a branch, for easier merging
gstash() {
  local out q k sha
  while out=$(
    git stash list --pretty="%C(yellow)%h %>(14)%Cgreen%cr %C(blue)%gs" |
    fzf --ansi --no-sort --query="$q" --print-query \
        --expect=ctrl-d,ctrl-b);
  do
    mapfile -t out <<< "$out"
    q="${out[0]}"
    k="${out[1]}"
    sha="${out[-1]}"
    sha="${sha%% *}"
    [[ -z "$sha" ]] && continue
    if [[ "$k" == 'ctrl-d' ]]; then
      git diff $sha
    elif [[ "$k" == 'ctrl-b' ]]; then
      git stash branch "stash-$sha" $sha
      break;
    else
      git stash show -p $sha
    fi
  done
}

# git tags
gt() {
  is_in_git_repo || return
  git tag --sort -version:refname |
  fzf-down --multi --preview-window right:70% \
    --preview 'git show --color=always {} | head -'$LINES
}

# fstash - easier way to deal with stashes
# type fstash to get a list of your stashes
# enter shows you the contents of the stash
# ctrl-d shows a diff of the stash against your current HEAD
# ctrl-b checks the stash out as a branch, for easier merging
fstash() {
  local out q k sha
  while out=$(
    git stash list --pretty="%C(yellow)%h %>(14)%Cgreen%cr %C(blue)%gs" |
    fzf --ansi --no-sort --query="$q" --print-query \
        --expect=ctrl-d,ctrl-b);
  do
    mapfile -t out <<< "$out"
    q="${out[0]}"
    k="${out[1]}"
    sha="${out[-1]}"
    sha="${sha%% *}"
    [[ -z "$sha" ]] && continue
    if [[ "$k" == 'ctrl-d' ]]; then
      git diff $sha
    elif [[ "$k" == 'ctrl-b' ]]; then
      git stash branch "stash-$sha" $sha
      break;
    else
      git stash show -p $sha
    fi
  done
}

# Azure functions to keep costs down
aks_up() {
  # : Usage: aks_up [resource_group]
  # : "This will start the VM's associated with a Resource Group "
  nodeResourceGroup=$(az aks list --query '[].nodeResourceGroup' -o table  | fzf-down --header-lines=2)
  az vm start --ids \
    "$(az vm list -g "$nodeResourceGroup" --query '[].id' -o tsv)"
  # az vm start --ids $(az vm list -g "$nodeResourceGroup" --query '[].id' -o tsv)
}

aks_down() {
  # : Usage: aks_down [resource_group]
  # : "This will deallocate the VM's associated with a Resource Group"
  nodeResourceGroup=$(az aks list --query '[].nodeResourceGroup' -o table  | fzf-down --header-lines=2)
  az vm deallocate --ids $(az vm list -g "${nodeResourceGroup}" --query "[].id" -o tsv)
}

# Fuzzy Azure account switch
function faz() {
  query='[].{name: name, subscriptionId: id}'
  az account set --subscription \
  "$(az account list -o table \
    --query '[].{name: name, subscriptionId: id}' | \
    fzf-down --header-lines=2 --nth='1,2' \
        --height="50%" \
        --min-height=17 \
        --preview='az account show -o json -s {-1}| jq -C' \
      | rev | cut -d' ' -f1 | rev
  )" &&  az account show
}

# Convert a "GIF" from a tweet (which is actually an mp4) into an actual GIF animation.
gifitter() {
  twiturl=$1
  youtube-dl -o - "${twiturl}" | ffmpeg -i - -r 15 -vf scale=512:-1 -f gif ohwow.gif

}

# jq-repl() {
# # pulled from reegnz/jq-zsh-plugin
# if [[ -z $1 ]] || [[ $1 == "-" ]]; then
#   input=$(mktemp)
#   trap "rm -f $input" EXIT
#   cat /dev/stdin > $input
# else
#   input=$1
# fi
# </dev/null fzf --phony \
#                --print-query \
#                --preview "jq --color-output -r {q} $input" \
#                --preview-window="down:99%" \
#                --height="99%" \
#                --query="." \
#                --bind "alt-up:preview-page-up, alt-down:preview-page-down"
# }

function duration() {
  ffmpeg -i $1 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//
}

function t2secs() {
  local time=${1}
  echo $time | awk -F: '{ print ($1 * 3600) + ($2 * 60) + int($3) }'
}

vs(){
  #List all vagrant boxes available in the system including its status, and try to access the selected one via ssh
  cd $(cat ~/.vagrant.d/data/machine-index/index | jq '.machines[] | {name, vagrantfile_path, state}' | jq '.name + "," + .state  + "," + .vagrantfile_path'| sed 's/^"\(.*\)"$/\1/'| column -s, -t | sort -rk 2 | fzf | awk '{print $3}'); vagrant ssh
}

markdown-to-adoc() (
  # Markdown to asciidoc the way I like it.
  f="$1"
  shift
  pandoc --atx-headers --base-header-level 2 -o "${f%.*}.adoc" --wrap=none "$f" "$@"
)
